{"version":3,"sources":["webpack:///./index.js","webpack:///../src/infact.js","webpack:///./demo.js","webpack:///../~/pigeon-maps/infact.js","webpack:///../~/pigeon-maps/lib/react/index.js","webpack:///../~/pigeon-maps/lib/react/infact.js","webpack:///../~/pigeon-maps/lib/react/utils/parent-position.js","webpack:///../~/pigeon-maps/lib/react/utils/parent-has-class.js","webpack:///../~/pigeon-maps/lib/react/utils/debounce.js","webpack:///../src/index.js","webpack:///../src/Cluster.js","webpack:///../~/supercluster/index.js","webpack:///../~/kdbush/src/kdbush.js","webpack:///../~/kdbush/src/sort.js","webpack:///../~/kdbush/src/range.js","webpack:///../~/kdbush/src/within.js","webpack:///../src/DefaultClusterMarker.js","webpack:///../~/pigeon-marker/infact.js","webpack:///../~/pigeon-marker/lib/react/index.js","webpack:///../~/pigeon-marker/lib/react/infact.js","webpack:///../~/pigeon-marker/lib/react/img/pin.png","webpack:///../~/pigeon-marker/lib/react/img/pin@2x.png","webpack:///../~/pigeon-marker/lib/react/img/pin-hover.png","webpack:///../~/pigeon-marker/lib/react/img/pin-hover@2x.png","webpack:///./index.html"],"names":["render","document","getElementById","exports","Inferno","require","ReactDOM","Component","PropTypes","React","Demo","textAlign","marginTop","Cluster","cloneElement","cloneVNode","iLNG","iLAT","props","Array","isArray","children","mapState","pixelToLatLng","latLngToPixel","clusterMarkerRadius","maxZoom","markers","map","marker","pixel","anchor","left","top","pointsForClustering","vNode","geometry","coordinates","index","radius","load","bounds","ne","sw","westLng","southLat","eastLng","northLat","markersAndClusters","getClusters","Math","floor","zoom","displayElements","displayElement","isCluster","markerOrCluster","properties","cluster","pixelOffset","clusterElementKey","toString","point_count","className","position","height","width","DefaultClusterMarker","colors","small","medium","big","defaultCountToColor","count","styleFromCount","borderRadius","borderWidth","borderColor","borderStyle","background","display","flexDirection","justifyContent","cursor","Object","assign"],"mappings":";;;;;;;;;;;;;;;AAAA;;AAEA;;;;AAEA;;;;AAEA,kBAASA,MAAT,CACI,iDADJ,EAEIC,SAASC,cAAT,CAAwB,MAAxB,CAFJ,E;;;;;;;;;ACNA;;AAEA,YAAyC;AACrCC,aAAQC,OAAR,GAAkBC,QAAQ,SAAR,CAAlB;AACAF,aAAQG,QAAR,GAAmBH,QAAQC,OAA3B;AACAD,aAAQI,SAAR,GAAoBF,QAAQ,mBAAR,CAApB;AACAF,aAAQK,SAAR,GAAoB,EAApB;AACH;AACD,WAAuC;AACnCL,aAAQM,KAAR,GAAgB,mBAAAJ,CAAQ,CAAR,CAAhB;AACAF,aAAQG,QAAR,GAAmB,mBAAAD,CAAQ,EAAR,CAAnB;AACAF,aAAQI,SAAR,GAAoBJ,QAAQM,KAAR,CAAcF,SAAlC;AACAJ,aAAQK,SAAR,GAAoBL,QAAQM,KAAR,CAAcD,SAAlC;AACH,E;;;;;;;;;;;;;;;ACbD;;AAEA;;;;AACA;;;;AACA;;;;;;;;;;;;KAEqBE,I;;;;;;;;;;;kCACP;AACN,oBACI;AAAA;AAAA,mBAAK,OAAO,EAAEC,WAAW,QAAb,EAAuBC,WAAW,EAAlC,EAAZ;AACI;AAAA;AAAA,uBAAK,QAAQ,CAAC,MAAD,EAAS,MAAT,CAAb;AACK,+BAAM,EADX;AAEK,gCAAO,GAFZ;AAGK,iCAAQ,GAHb;AAII;AAAA;AAAA;AACI,yEAAQ,KAAI,IAAZ,EAAiB,QAAQ,CAAC,MAAD,EAAS,MAAT,CAAzB,EAA2C,SAAS,CAApD,GADJ;AAEI,yEAAQ,KAAI,IAAZ,EAAiB,QAAQ,CAAC,MAAD,EAAS,GAAT,CAAzB,EAAwC,SAAS,CAAjD,GAFJ;AAGI,yEAAQ,KAAI,IAAZ,EAAiB,QAAQ,CAAC,MAAD,EAAS,IAAT,CAAzB,EAAyC,SAAS,CAAlD;AAHJ;AAJJ;AADJ,cADJ;AAcH;;;;;;mBAhBgBF,I;;;;;;;ACNrB;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACLA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA,oBAAmB,kBAAkB;AACrC,iCAAgC,uDAAuD,+BAA+B,sDAAsD;AAC5K;AACA,IAAG;AACH,yEAAwE,4DAA4D;AACpI;AACA,EAAC;;AAED;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,yCAAwC;AACxC;;AAEA;AACA;AACA,8CAA6C,gBAAgB;AAC7D;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG,wEAAwE,eAAe,yEAAyE,EAAE,EAAE;AACvK;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAgB;AAChB,QAAO;AACP;;AAEA,iBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2DAA0D,oCAAoC;AAC9F;;AAEA;AACA;AACA;AACA,cAAa;AACb,YAAW;;AAEX;;AAEA,4CAA2C,0BAA0B;AACrE,8CAA6C,0BAA0B;AACvE;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT;;AAEA,uBAAsB,oCAAoC;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA,2BAA0B,eAAe;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,gCAA+B,6CAA6C;AAC5E,2BAA0B,mBAAmB;AAC7C,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,sDAAsD;AAClF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAgC,uCAAuC;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAAyB,4EAA4E;;AAErG;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;;AAEA;;AAEA,IAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAqB,qBAAqB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA2B,YAAY;AACvC,8BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA2B,cAAc;AACzC,4BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA,kDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS,EAAE,sCAAsC;AACjD;AACA;AACA;AACA;AACA;AACA,UAAS,EAAE;AACX,oDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,mBAAkB,oJAAoJ,EAAE;AACxK,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;;;AAGA,kDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,UAAS,EAAE;AACX;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS,EAAE,wIAAwI,uEAAuE,uHAAuH,oEAAoE;AACrZ;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,kDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,oCAAmC;AACnC;AACA,IAAG;;AAEH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uB;;;;;;;ACv7BA;;AAEA;;AAEA;AACA;AACA;AACA,6C;;;;;;;ACPA;;AAEA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAU;AACV,E;;;;;;;ACnBA;;AAEA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A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AAK;;AAEL;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2CAA0C,2BAA2B;AACrE;;AAEA;AACA;;AAEA,mDAAkD;;AAElD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA,wBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA,mCAAkC;AAClC,6CAA4C;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClOA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA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","file":"demo.bundle.js","sourcesContent":["import { React, ReactDOM, Inferno } from '../src/infact'\n\nimport Demo from './demo'\n\nimport './index.html'\n\nReactDOM.render(\n    <Demo />,\n    document.getElementById('root')\n)\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","// // infact = inferno + react\n\nif (process.env.BABEL_ENV === 'inferno') {\n    exports.Inferno = require('inferno')\n    exports.ReactDOM = exports.Inferno\n    exports.Component = require('inferno-component')\n    exports.PropTypes = {}\n}\nif (process.env.BABEL_ENV === 'react') {\n    exports.React = require('react')\n    exports.ReactDOM = require('react-dom')\n    exports.Component = exports.React.Component\n    exports.PropTypes = exports.React.PropTypes\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/infact.js","import {React, Inferno, Component} from '../src/infact'\n\nimport Map from 'pigeon-maps/infact'\nimport Cluster from 'pigeon-cluster'\nimport Marker from 'pigeon-marker/infact'\n\nexport default class Demo extends Component {\n    render () {\n        return (\n            <div style={{ textAlign: 'center', marginTop: 50 }}>\n                <Map center={[50.879, 4.6997]}\n                     zoom={11}\n                     width={600}\n                     height={400}>\n                    <Cluster>\n                        <Marker key='m1' anchor={[50.889, 4.6997]} payload={1}/>\n                        <Marker key='m2' anchor={[50.879, 4.7]} payload={1}/>\n                        <Marker key='m3' anchor={[50.869, 4.72]} payload={1}/>\n                    </Cluster>\n                </Map>\n            </div>\n        )\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./demo.js","if (process.env.BABEL_ENV === 'inferno') {\n  module.exports = require('./lib/inferno/index.js')\n}\nif (process.env.BABEL_ENV === 'react') {\n  module.exports = require('./lib/react/index.js')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-maps/infact.js\n// module id = 169\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nvar _infact = require('./infact');\n\nvar _parentPosition = require('./utils/parent-position');\n\nvar _parentPosition2 = _interopRequireDefault(_parentPosition);\n\nvar _parentHasClass = require('./utils/parent-has-class');\n\nvar _parentHasClass2 = _interopRequireDefault(_parentHasClass);\n\nvar _debounce = require('./utils/debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar ANIMATION_TIME = 300;\nvar DIAGONAL_THROW_TIME = 1500;\nvar SCROLL_PIXELS_FOR_ZOOM_LEVEL = 150;\nvar MIN_DRAG_FOR_THROW = 40;\nvar CLICK_TOLERANCE = 2;\nvar DOUBLE_CLICK_DELAY = 300;\nvar DEBOUNCE_DELAY = 60;\n\nvar NOOP = function () {};\n\nfunction wikimedia(x, y, z) {\n  var retina = typeof window !== 'undefined' && window.devicePixelRatio >= 2;\n  return 'https://maps.wikimedia.org/osm-intl/' + z + '/' + x + '/' + y + (retina ? '@2x' : '') + '.png';\n}\n\n// https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames\nvar lng2tile = function (lon, zoom) {\n  return (lon + 180) / 360 * Math.pow(2, zoom);\n};\nvar lat2tile = function (lat, zoom) {\n  return (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom);\n};\n\nfunction tile2lng(x, z) {\n  return x / Math.pow(2, z) * 360 - 180;\n}\n\nfunction tile2lat(y, z) {\n  var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);\n  return 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n}\n\nfunction getMousePixel(dom, event) {\n  var parent = (0, _parentPosition2.default)(dom);\n  return [event.clientX - parent.x, event.clientY - parent.y];\n}\n\nfunction easeOutQuad(t) {\n  return t * (2 - t);\n}\n\nvar minLng = tile2lng(0, 10);\nvar minLat = tile2lat(Math.pow(2, 10), 10);\n\nvar maxLng = tile2lng(Math.pow(2, 10), 10);\nvar maxLat = tile2lat(0, 10);\n\nvar Map = function (_Component) {\n  _inherits(Map, _Component);\n\n  function Map(props) {\n    _classCallCheck(this, Map);\n\n    var _this = _possibleConstructorReturn(this, (Map.__proto__ || Object.getPrototypeOf(Map)).call(this, props));\n\n    _this.setCenterZoomTarget = function (center, zoom, fromProps) {\n      var zoomAround = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var animationDuration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ANIMATION_TIME;\n\n      // TODO: if center diff is more than 2 screens, no animation\n      if (_this.props.animate) {\n        if (_this._isAnimating) {\n          window.cancelAnimationFrame(_this._animFrame);\n\n          var _this$animationStep = _this.animationStep(window.performance.now()),\n              centerStep = _this$animationStep.centerStep,\n              zoomStep = _this$animationStep.zoomStep;\n\n          _this._centerStart = centerStep;\n          _this._zoomStart = zoomStep;\n        } else {\n          _this._isAnimating = true;\n          _this._centerStart = _this.limitCenterAtZoom([_this._lastCenter[0], _this._lastCenter[1]], _this._lastZoom);\n          _this._zoomStart = _this._lastZoom;\n        }\n\n        _this._animationStart = window.performance.now();\n        _this._animationEnd = _this._animationStart + animationDuration;\n\n        if (zoomAround) {\n          _this._zoomAround = zoomAround;\n          _this._centerTarget = _this.calculateZoomCenter(_this._lastCenter, zoomAround, _this._lastZoom, zoom);\n        } else {\n          _this._zoomAround = null;\n          _this._centerTarget = center;\n        }\n        _this._zoomTarget = zoom;\n\n        _this._animFrame = window.requestAnimationFrame(_this.animate);\n      } else {\n        if (zoomAround) {\n          var _center = _this.calculateZoomCenter(_this._lastCenter, zoomAround, _this._lastZoom, zoom);\n          _this.setCenterZoom(_center, zoom, fromProps);\n        } else {\n          _this.setCenterZoom(center, zoom, fromProps);\n        }\n      }\n    };\n\n    _this.animationStep = function (timestamp) {\n      var length = _this._animationEnd - _this._animationStart;\n      var progress = Math.max(timestamp - _this._animationStart, 0);\n      var percentage = easeOutQuad(progress / length);\n\n      var zoomDiff = (_this._zoomTarget - _this._zoomStart) * percentage;\n      var zoomStep = _this._zoomStart + zoomDiff;\n\n      if (_this._zoomAround) {\n        var centerStep = _this.calculateZoomCenter(_this._centerStart, _this._zoomAround, _this._zoomStart, zoomStep);\n\n        return { centerStep: centerStep, zoomStep: zoomStep };\n      } else {\n        var _centerStep = [_this._centerStart[0] + (_this._centerTarget[0] - _this._centerStart[0]) * percentage, _this._centerStart[1] + (_this._centerTarget[1] - _this._centerStart[1]) * percentage];\n\n        return { centerStep: _centerStep, zoomStep: zoomStep };\n      }\n    };\n\n    _this.animate = function (timestamp) {\n      if (timestamp >= _this._animationEnd) {\n        _this._isAnimating = false;\n        _this.setCenterZoom(_this._centerTarget, _this._zoomTarget);\n      } else {\n        var _this$animationStep2 = _this.animationStep(timestamp),\n            centerStep = _this$animationStep2.centerStep,\n            zoomStep = _this$animationStep2.zoomStep;\n\n        _this.setCenterZoom(centerStep, zoomStep);\n        _this._animFrame = window.requestAnimationFrame(_this.animate);\n      }\n    };\n\n    _this.stopAnimating = function () {\n      if (_this._isAnimating) {\n        _this._isAnimating = false;\n        window.cancelAnimationFrame(_this._animFrame);\n      }\n    };\n\n    _this.limitCenterAtZoom = function (center) {\n      // TODO: use zoom to hide the gray area of the map - adjust the center\n      return [Math.max(Math.min(isNaN(center[0]) ? _this.state.center[0] : center[0], maxLat), minLat), Math.max(Math.min(isNaN(center[1]) ? _this.state.center[1] : center[1], maxLng), minLng)];\n    };\n\n    _this.setCenterZoom = function (center, zoom) {\n      var limitedCenter = _this.limitCenterAtZoom(center, zoom);\n\n      if (Math.round(_this.state.zoom) !== Math.round(zoom)) {\n        (function () {\n          var tileValues = _this.tileValues(_this.props, _this.state);\n          var nextValues = _this.tileValues(_this.props, { center: limitedCenter, zoom: zoom });\n          var oldTiles = _this.state.oldTiles;\n\n          _this.setState({\n            oldTiles: oldTiles.filter(function (o) {\n              return o.roundedZoom !== tileValues.roundedZoom;\n            }).concat(tileValues)\n          }, NOOP);\n\n          var loadTracker = {};\n\n          for (var x = nextValues.tileMinX; x <= nextValues.tileMaxX; x++) {\n            for (var y = nextValues.tileMinY; y <= nextValues.tileMaxY; y++) {\n              var key = x + '-' + y + '-' + nextValues.roundedZoom;\n              loadTracker[key] = false;\n            }\n          }\n\n          _this._loadTracker = loadTracker;\n        })();\n      }\n\n      _this.setState({ center: limitedCenter, zoom: zoom }, NOOP);\n\n      var maybeZoom = _this.props.zoom ? _this.props.zoom : _this._lastZoom;\n      var maybeCenter = _this.props.center ? _this.props.center : _this._lastCenter;\n      if (Math.abs(maybeZoom - zoom) > 0.001 || Math.abs(maybeCenter[0] - limitedCenter[0]) > 0.00001 || Math.abs(maybeCenter[1] - limitedCenter[1]) > 0.00001) {\n        _this._lastZoom = zoom;\n        _this._lastCenter = [].concat(_toConsumableArray(limitedCenter));\n        _this.syncToProps(limitedCenter, zoom);\n      }\n    };\n\n    _this.imageLoaded = function (key) {\n      if (_this._loadTracker && key in _this._loadTracker) {\n        _this._loadTracker[key] = true;\n\n        var unloadedCount = Object.keys(_this._loadTracker).filter(function (k) {\n          return !_this._loadTracker[k];\n        }).length;\n\n        if (unloadedCount === 0) {\n          _this.setState({ oldTiles: [] }, NOOP);\n        }\n      }\n    };\n\n    _this.handleTouchStart = function (event) {\n      var _this$props = _this.props,\n          width = _this$props.width,\n          height = _this$props.height;\n\n      if (event.touches.length === 1) {\n        var touch = event.touches[0];\n        var pixel = getMousePixel(_this._containerRef, touch);\n\n        if (pixel[0] >= 0 && pixel[1] >= 0 && pixel[0] < width && pixel[1] < height) {\n          _this._touchStartCoords = [[touch.clientX, touch.clientY]];\n\n          _this.stopAnimating();\n          event.preventDefault();\n\n          if (_this._lastTap && window.performance.now() - _this._lastTap < DOUBLE_CLICK_DELAY) {\n            var latLngNow = _this.pixelToLatLng(_this._touchStartCoords[0]);\n            _this.setCenterZoomTarget(null, Math.max(1, Math.min(_this.state.zoom + 1, 18)), false, latLngNow);\n          } else {\n            _this._lastTap = window.performance.now();\n            _this.startTrackingMoveEvents(pixel);\n          }\n        }\n        // added second finger and first one was in the area\n      } else if (event.touches.length === 2 && _this._touchStartCoords) {\n        event.preventDefault();\n\n        _this.stopTrackingMoveEvents();\n\n        if (_this.state.pixelDelta || _this.state.zoomDelta) {\n          _this.sendDeltaChange();\n        }\n\n        var t1 = event.touches[0];\n        var t2 = event.touches[1];\n\n        _this._touchStartCoords = [[t1.clientX, t1.clientY], [t2.clientX, t2.clientY]];\n        _this._touchStartMidPoint = [(t1.clientX + t2.clientX) / 2, (t1.clientY + t2.clientY) / 2];\n        _this._touchStartDistance = Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2));\n      }\n    };\n\n    _this.handleTouchMove = function (event) {\n      if (event.touches.length === 1 && _this._touchStartCoords) {\n        event.preventDefault();\n        var touch = event.touches[0];\n        var pixel = getMousePixel(_this._containerRef, touch);\n        _this.trackMoveEvents(pixel);\n\n        _this.setState({\n          pixelDelta: [touch.clientX - _this._touchStartCoords[0][0], touch.clientY - _this._touchStartCoords[0][1]]\n        }, NOOP);\n      } else if (event.touches.length === 2 && _this._touchStartCoords) {\n        var _this$props2 = _this.props,\n            width = _this$props2.width,\n            height = _this$props2.height;\n        var zoom = _this.state.zoom;\n\n        event.preventDefault();\n\n        var t1 = event.touches[0];\n        var t2 = event.touches[1];\n\n        var parent = (0, _parentPosition2.default)(_this._containerRef);\n\n        var midPoint = [(t1.clientX + t2.clientX) / 2, (t1.clientY + t2.clientY) / 2];\n        var midPointDiff = [midPoint[0] - _this._touchStartMidPoint[0], midPoint[1] - _this._touchStartMidPoint[1]];\n\n        var distance = Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2));\n\n        var zoomDelta = Math.min(18, zoom + Math.log2(distance / _this._touchStartDistance)) - zoom;\n        var scale = Math.pow(2, zoomDelta);\n\n        var centerDiffDiff = [(parent.x + width / 2 - midPoint[0]) * (scale - 1), (parent.y + height / 2 - midPoint[1]) * (scale - 1)];\n\n        _this.setState({\n          zoomDelta: zoomDelta,\n          pixelDelta: [centerDiffDiff[0] + midPointDiff[0] * scale, centerDiffDiff[1] + midPointDiff[1] * scale]\n        }, NOOP);\n      }\n    };\n\n    _this.handleTouchEnd = function (event) {\n      if (_this._touchStartCoords) {\n        event.preventDefault();\n\n        var _this$sendDeltaChange = _this.sendDeltaChange(),\n            center = _this$sendDeltaChange.center,\n            zoom = _this$sendDeltaChange.zoom;\n\n        if (event.touches.length === 0) {\n          _this._touchStartCoords = null;\n          var pixel = getMousePixel(_this._containerRef, event.changedTouches[0]);\n          _this.throwAfterMoving(pixel, center, zoom);\n        } else if (event.touches.length === 1) {\n          var touch = event.touches[0];\n          var _pixel = getMousePixel(_this._containerRef, touch);\n\n          _this._touchStartCoords = [[touch.clientX, touch.clientY]];\n          _this.startTrackingMoveEvents(_pixel);\n        }\n      }\n    };\n\n    _this.handleMouseDown = function (event) {\n      var _this$props3 = _this.props,\n          width = _this$props3.width,\n          height = _this$props3.height;\n\n      var pixel = getMousePixel(_this._containerRef, event);\n\n      if (event.button === 0 && !(0, _parentHasClass2.default)(event.target, 'pigeon-drag-block') && pixel[0] >= 0 && pixel[1] >= 0 && pixel[0] < width && pixel[1] < height) {\n        _this.stopAnimating();\n        event.preventDefault();\n\n        if (_this._lastClick && window.performance.now() - _this._lastClick < DOUBLE_CLICK_DELAY) {\n          var latLngNow = _this.pixelToLatLng(_this._mousePosition);\n          _this.setCenterZoomTarget(null, Math.max(1, Math.min(_this.state.zoom + 1, 18)), false, latLngNow);\n        } else {\n          _this._lastClick = window.performance.now();\n\n          _this._mouseDown = true;\n          _this._dragStart = pixel;\n          _this.startTrackingMoveEvents(pixel);\n        }\n      }\n    };\n\n    _this.handleMouseMove = function (event) {\n      _this._mousePosition = getMousePixel(_this._containerRef, event);\n\n      if (_this._mouseDown && _this._dragStart) {\n        _this.trackMoveEvents(_this._mousePosition);\n        _this.setState({\n          pixelDelta: [_this._mousePosition[0] - _this._dragStart[0], _this._mousePosition[1] - _this._dragStart[1]]\n        }, NOOP);\n      }\n    };\n\n    _this.handleMouseUp = function (event) {\n      var pixelDelta = _this.state.pixelDelta;\n\n      if (_this._mouseDown) {\n        _this._mouseDown = false;\n\n        var pixel = getMousePixel(_this._containerRef, event);\n\n        if (_this.props.onClick && !(0, _parentHasClass2.default)(event.target, 'pigeon-click-block') && (!pixelDelta || Math.abs(pixelDelta[0]) + Math.abs(pixelDelta[1]) <= CLICK_TOLERANCE)) {\n          var latLng = _this.pixelToLatLng(pixel);\n          _this.props.onClick({ event: event, latLng: latLng, pixel: pixel });\n          _this.setState({ pixelDelta: null }, NOOP);\n        } else {\n          var _this$sendDeltaChange2 = _this.sendDeltaChange(),\n              center = _this$sendDeltaChange2.center,\n              zoom = _this$sendDeltaChange2.zoom;\n\n          _this.throwAfterMoving(pixel, center, zoom);\n        }\n      }\n    };\n\n    _this.startTrackingMoveEvents = function (coords) {\n      _this._moveEvents = [{ timestamp: window.performance.now(), coords: coords }];\n    };\n\n    _this.stopTrackingMoveEvents = function () {\n      _this._moveEvents = [];\n    };\n\n    _this.trackMoveEvents = function (coords) {\n      var timestamp = window.performance.now();\n\n      if (timestamp - _this._moveEvents[_this._moveEvents.length - 1].timestamp > 40) {\n        _this._moveEvents.push({ timestamp: timestamp, coords: coords });\n        if (_this._moveEvents.length > 2) {\n          _this._moveEvents.shift();\n        }\n      }\n    };\n\n    _this.throwAfterMoving = function (coords, center, zoom) {\n      var _this$props4 = _this.props,\n          width = _this$props4.width,\n          height = _this$props4.height,\n          animate = _this$props4.animate;\n\n      var timestamp = window.performance.now();\n      var lastEvent = _this._moveEvents.shift();\n\n      if (lastEvent && animate) {\n        var deltaMs = Math.max(timestamp - lastEvent.timestamp, 1);\n\n        var delta = [(coords[0] - lastEvent.coords[0]) / deltaMs * 120, (coords[1] - lastEvent.coords[1]) / deltaMs * 120];\n\n        var distance = Math.sqrt(delta[0] * delta[0] + delta[1] * delta[1]);\n\n        if (distance > MIN_DRAG_FOR_THROW) {\n          var diagonal = Math.sqrt(width * width + height * height);\n\n          var lng = tile2lng(lng2tile(center[1], zoom) - delta[0] / 256.0, zoom);\n          var lat = tile2lat(lat2tile(center[0], zoom) - delta[1] / 256.0, zoom);\n\n          _this.setCenterZoomTarget([lat, lng], zoom, false, null, DIAGONAL_THROW_TIME * distance / diagonal);\n        }\n      }\n\n      _this.stopTrackingMoveEvents();\n    };\n\n    _this.sendDeltaChange = function () {\n      var _this$state = _this.state,\n          center = _this$state.center,\n          zoom = _this$state.zoom,\n          pixelDelta = _this$state.pixelDelta,\n          zoomDelta = _this$state.zoomDelta;\n\n      var lat = center[0];\n      var lng = center[1];\n\n      if (pixelDelta || zoomDelta !== 0) {\n        lng = tile2lng(lng2tile(center[1], zoom + zoomDelta) - (pixelDelta ? pixelDelta[0] / 256.0 : 0), zoom + zoomDelta);\n        lat = tile2lat(lat2tile(center[0], zoom + zoomDelta) - (pixelDelta ? pixelDelta[1] / 256.0 : 0), zoom + zoomDelta);\n        _this.setCenterZoom([lat, lng], zoom + zoomDelta);\n      }\n\n      _this.setState({\n        pixelDelta: null,\n        zoomDelta: 0\n      }, NOOP);\n\n      return {\n        center: _this.limitCenterAtZoom([lat, lng], zoom + zoomDelta),\n        zoom: zoom + zoomDelta\n      };\n    };\n\n    _this.getBounds = function () {\n      var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.state.center;\n      var zoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.zoomPlusDelta();\n      var _this$props5 = _this.props,\n          width = _this$props5.width,\n          height = _this$props5.height;\n\n      return {\n        ne: _this.pixelToLatLng([width - 1, 0], center, zoom),\n        sw: _this.pixelToLatLng([0, height - 1], center, zoom)\n      };\n    };\n\n    _this.syncToProps = function () {\n      var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.state.center;\n      var zoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.state.zoom;\n      var onBoundsChanged = _this.props.onBoundsChanged;\n\n      if (onBoundsChanged) {\n        var bounds = _this.getBounds(center, zoom);\n\n        onBoundsChanged({ center: center, zoom: zoom, bounds: bounds, initial: !_this._boundsSynced });\n\n        _this._boundsSynced = true;\n      }\n    };\n\n    _this.handleWheel = function (event) {\n      event.preventDefault();\n\n      var addToZoom = -event.deltaY / SCROLL_PIXELS_FOR_ZOOM_LEVEL;\n\n      if (_this._zoomTarget) {\n        var stillToAdd = _this._zoomTarget - _this.state.zoom;\n        _this.zoomAroundMouse(addToZoom + stillToAdd);\n      } else {\n        _this.zoomAroundMouse(addToZoom);\n      }\n    };\n\n    _this.zoomAroundMouse = function (zoomDiff) {\n      var zoom = _this.state.zoom;\n\n      if (!_this._mousePosition || zoom === 1 && zoomDiff < 0 || zoom === 18 && zoomDiff > 0) {\n        return;\n      }\n\n      var latLngNow = _this.pixelToLatLng(_this._mousePosition);\n\n      _this.setCenterZoomTarget(null, Math.max(1, Math.min(zoom + zoomDiff, 18)), false, latLngNow);\n    };\n\n    _this.zoomPlusDelta = function () {\n      return _this.state.zoom + _this.state.zoomDelta;\n    };\n\n    _this.pixelToLatLng = function (pixel) {\n      var center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.state.center;\n      var zoom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _this.zoomPlusDelta();\n      var _this$props6 = _this.props,\n          width = _this$props6.width,\n          height = _this$props6.height;\n      var pixelDelta = _this.state.pixelDelta;\n\n      var pointDiff = [(pixel[0] - width / 2 - (pixelDelta ? pixelDelta[0] : 0)) / 256.0, (pixel[1] - height / 2 - (pixelDelta ? pixelDelta[1] : 0)) / 256.0];\n\n      var tileX = lng2tile(center[1], zoom) + pointDiff[0];\n      var tileY = lat2tile(center[0], zoom) + pointDiff[1];\n\n      return _this.limitCenterAtZoom([tile2lat(tileY, zoom), tile2lng(tileX, zoom)], zoom);\n    };\n\n    _this.latLngToPixel = function (latLng) {\n      var center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.state.center;\n      var zoom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _this.zoomPlusDelta();\n      var _this$props7 = _this.props,\n          width = _this$props7.width,\n          height = _this$props7.height;\n      var pixelDelta = _this.state.pixelDelta;\n\n      var limitedCenter = _this.limitCenterAtZoom(center);\n\n      var tileCenterX = lng2tile(limitedCenter[1], zoom);\n      var tileCenterY = lat2tile(limitedCenter[0], zoom);\n\n      var tileX = lng2tile(latLng[1], zoom);\n      var tileY = lat2tile(latLng[0], zoom);\n\n      return [(tileX - tileCenterX) * 256.0 + width / 2 + (pixelDelta ? pixelDelta[0] : 0), (tileY - tileCenterY) * 256.0 + height / 2 + (pixelDelta ? pixelDelta[1] : 0)];\n    };\n\n    _this.calculateZoomCenter = function (center, coords, oldZoom, newZoom) {\n      var _this$props8 = _this.props,\n          width = _this$props8.width,\n          height = _this$props8.height;\n\n      var pixelBefore = _this.latLngToPixel(coords, center, oldZoom);\n      var pixelAfter = _this.latLngToPixel(coords, center, newZoom);\n\n      var newCenter = _this.pixelToLatLng([width / 2 + pixelAfter[0] - pixelBefore[0], height / 2 + pixelAfter[1] - pixelBefore[1]], center, newZoom);\n\n      return _this.limitCenterAtZoom(newCenter, newZoom);\n    };\n\n    _this.setRef = function (dom) {\n      _this._containerRef = dom;\n    };\n\n    _this.syncToProps = (0, _debounce2.default)(_this.syncToProps, DEBOUNCE_DELAY);\n\n    _this._mousePosition = null;\n    _this._dragStart = null;\n    _this._mouseDown = false;\n    _this._moveEvents = [];\n    _this._lastClick = null;\n    _this._lastTap = null;\n    _this._touchStartCoords = null;\n\n    _this._isAnimating = false;\n    _this._animationStart = null;\n    _this._animationEnd = null;\n    _this._centerTarget = null;\n    _this._zoomTarget = null;\n\n    // When users are using uncontrolled components we have to keep this\n    // so we can know if we should call onBoundsChanged\n    _this._lastZoom = props.defaultZoom ? props.defaultZoom : props.zoom;\n    _this._lastCenter = props.defaultCenter ? props.defaultCenter : props.center;\n    _this._boundsSynced = false;\n\n    _this.state = {\n      zoom: _this._lastZoom,\n      center: _this._lastCenter,\n      zoomDelta: 0,\n      pixelDelta: null,\n      oldTiles: []\n    };\n    return _this;\n  }\n\n  _createClass(Map, [{\n    key: 'componentDidMount',\n    value: function () {\n      var wa = window.addEventListener;\n      wa('mousedown', this.handleMouseDown);\n      wa('mouseup', this.handleMouseUp);\n      wa('mousemove', this.handleMouseMove);\n\n      wa('touchstart', this.handleTouchStart);\n      wa('touchmove', this.handleTouchMove);\n      wa('touchend', this.handleTouchEnd);\n\n      this.syncToProps();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function () {\n      var wr = window.removeEventListener;\n      wr('mousedown', this.handleMouseDown);\n      wr('mouseup', this.handleMouseUp);\n      wr('mousemove', this.handleMouseMove);\n\n      wr('touchstart', this.handleTouchStart);\n      wr('touchmove', this.handleTouchMove);\n      wr('touchend', this.handleTouchEnd);\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function (nextProps) {\n      if (!nextProps.center && !nextProps.zoom) {\n        // if the user isn't controlling neither zoom nor center we don't have to update.\n        return;\n      }\n      var maybeCenter = nextProps.center ? nextProps.center : this.state.center;\n      var maybeZoom = nextProps.zoom ? nextProps.zoom : this.state.zoom;\n      if (Math.abs(maybeZoom - this.state.zoom) > 0.001 || Math.abs(maybeCenter[0] - this.state.center[0]) > 0.0001 || Math.abs(maybeCenter[1] - this.state.center[1]) > 0.0001) {\n        this.setCenterZoomTarget(maybeCenter, maybeZoom, true);\n      }\n    }\n\n    // main logic when changing coordinates\n\n\n    // https://www.bennadel.com/blog/1856-using-jquery-s-animate-step-callback-function-to-create-custom-animations.htm\n\n\n    // tools\n\n    // ref\n\n  }, {\n    key: 'tileValues',\n\n    // data to display the tiles\n\n    value: function (props, state) {\n      var width = props.width,\n          height = props.height;\n      var center = state.center,\n          zoom = state.zoom,\n          pixelDelta = state.pixelDelta,\n          zoomDelta = state.zoomDelta;\n\n      var roundedZoom = Math.round(zoom + (zoomDelta || 0));\n\n\n      var scale = Math.pow(2, zoom + (zoomDelta || 0) - roundedZoom);\n      var scaleWidth = width / scale;\n      var scaleHeight = height / scale;\n\n      var tileCenterX = lng2tile(center[1], roundedZoom) - (pixelDelta ? pixelDelta[0] / 256.0 / scale : 0);\n      var tileCenterY = lat2tile(center[0], roundedZoom) - (pixelDelta ? pixelDelta[1] / 256.0 / scale : 0);\n\n      var halfWidth = scaleWidth / 2 / 256.0;\n      var halfHeight = scaleHeight / 2 / 256.0;\n\n      var tileMinX = Math.floor(tileCenterX - halfWidth);\n      var tileMaxX = Math.floor(tileCenterX + halfWidth);\n\n      var tileMinY = Math.floor(tileCenterY - halfHeight);\n      var tileMaxY = Math.floor(tileCenterY + halfHeight);\n\n      return {\n        tileMinX: tileMinX,\n        tileMaxX: tileMaxX,\n        tileMinY: tileMinY,\n        tileMaxY: tileMaxY,\n        tileCenterX: tileCenterX,\n        tileCenterY: tileCenterY,\n        roundedZoom: roundedZoom,\n        zoomDelta: zoomDelta || 0,\n        scaleWidth: scaleWidth,\n        scaleHeight: scaleHeight,\n        scale: scale\n      };\n    }\n\n    // display the tiles\n\n  }, {\n    key: 'renderTiles',\n    value: function () {\n      var _this2 = this;\n\n      var oldTiles = this.state.oldTiles;\n\n      var mapUrl = this.props.provider || wikimedia;\n\n      var _tileValues = this.tileValues(this.props, this.state),\n          tileMinX = _tileValues.tileMinX,\n          tileMaxX = _tileValues.tileMaxX,\n          tileMinY = _tileValues.tileMinY,\n          tileMaxY = _tileValues.tileMaxY,\n          tileCenterX = _tileValues.tileCenterX,\n          tileCenterY = _tileValues.tileCenterY,\n          roundedZoom = _tileValues.roundedZoom,\n          scaleWidth = _tileValues.scaleWidth,\n          scaleHeight = _tileValues.scaleHeight,\n          scale = _tileValues.scale;\n\n      var tiles = [];\n\n      for (var i = 0; i < oldTiles.length; i++) {\n        var old = oldTiles[i];\n        var zoomDiff = old.roundedZoom - roundedZoom;\n\n        if (Math.abs(zoomDiff) > 4 || zoomDiff === 0) {\n          continue;\n        }\n\n        var pow = 1 / Math.pow(2, zoomDiff);\n        var xDiff = -(tileMinX - old.tileMinX * pow) * 256;\n        var yDiff = -(tileMinY - old.tileMinY * pow) * 256;\n\n        var _xMin = Math.max(old.tileMinX, 0);\n        var _yMin = Math.max(old.tileMinY, 0);\n        var _xMax = Math.min(old.tileMaxX, Math.pow(2, old.roundedZoom) - 1);\n        var _yMax = Math.min(old.tileMaxY, Math.pow(2, old.roundedZoom) - 1);\n\n        for (var x = _xMin; x <= _xMax; x++) {\n          for (var y = _yMin; y <= _yMax; y++) {\n            tiles.push({\n              key: x + '-' + y + '-' + old.roundedZoom,\n              url: mapUrl(x, y, old.roundedZoom),\n              left: xDiff + (x - old.tileMinX) * 256 * pow,\n              top: yDiff + (y - old.tileMinY) * 256 * pow,\n              width: 256 * pow,\n              height: 256 * pow,\n              active: false\n            });\n          }\n        }\n      }\n\n      var xMin = Math.max(tileMinX, 0);\n      var yMin = Math.max(tileMinY, 0);\n      var xMax = Math.min(tileMaxX, Math.pow(2, roundedZoom) - 1);\n      var yMax = Math.min(tileMaxY, Math.pow(2, roundedZoom) - 1);\n\n      for (var _x11 = xMin; _x11 <= xMax; _x11++) {\n        for (var _y = yMin; _y <= yMax; _y++) {\n          tiles.push({\n            key: _x11 + '-' + _y + '-' + roundedZoom,\n            url: mapUrl(_x11, _y, roundedZoom),\n            left: (_x11 - tileMinX) * 256,\n            top: (_y - tileMinY) * 256,\n            width: 256,\n            height: 256,\n            active: true\n          });\n        }\n      }\n\n      return _infact.React.createElement('div', { style: {\n          width: scaleWidth,\n          height: scaleHeight,\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          overflow: 'hidden',\n          willChange: 'transform',\n          transform: 'scale(' + scale + ', ' + scale + ')',\n          transformOrigin: 'top left'\n        } }, _infact.React.createElement('div', { style: {\n          position: 'absolute',\n          width: (tileMaxX - tileMinX + 1) * 256,\n          height: (tileMaxY - tileMinY + 1) * 256,\n          willChange: 'transform',\n          transform: 'translate(' + -((tileCenterX - tileMinX) * 256 - scaleWidth / 2) + 'px, ' + -((tileCenterY - tileMinY) * 256 - scaleHeight / 2) + 'px)'\n        } }, tiles.map(function (tile) {\n        return _infact.React.createElement('img', { key: tile.key,\n          src: tile.url,\n          width: tile.width,\n          height: tile.height,\n          onLoad: function () {\n            return _this2.imageLoaded(tile.key);\n          },\n          style: { position: 'absolute', left: tile.left, top: tile.top, willChange: 'transform', transform: tile.transform, transformOrigin: 'top left', opacity: 1 } });\n      })));\n    }\n  }, {\n    key: 'renderOverlays',\n    value: function () {\n      var _this3 = this;\n\n      var _props = this.props,\n          width = _props.width,\n          height = _props.height;\n      var center = this.state.center;\n\n      var mapState = {\n        bounds: this.getBounds(),\n        zoom: this.zoomPlusDelta(),\n        center: center,\n        width: width,\n        height: height\n      };\n\n      var childrenWithProps = void 0;\n\n      childrenWithProps = _infact.React.Children.map(this.props.children, function (child) {\n        var _child$props = child.props,\n            anchor = _child$props.anchor,\n            position = _child$props.position,\n            offset = _child$props.offset;\n\n        var c = _this3.latLngToPixel(anchor || position || center);\n\n        return _infact.React.cloneElement(child, {\n          left: c[0] - (offset ? offset[0] : 0),\n          top: c[1] - (offset ? offset[1] : 0),\n          latLngToPixel: _this3.latLngToPixel,\n          pixelToLatLng: _this3.pixelToLatLng,\n          mapState: mapState\n        });\n      });\n      var childrenChecked;\n\n\n      return _infact.React.createElement('div', { style: {\n          position: 'absolute',\n          width: width,\n          height: height,\n          top: 0,\n          left: 0\n        } }, childrenWithProps);\n    }\n  }, {\n    key: 'renderAttribution',\n    value: function () {\n      var _props2 = this.props,\n          attribution = _props2.attribution,\n          attributionPrefix = _props2.attributionPrefix;\n\n      if (attribution === false) {\n        return null;\n      }\n\n      var linkStyle = {\n        color: '#0078A8',\n        textDecoration: 'none'\n      };\n\n      return _infact.React.createElement('div', { key: 'attr', className: 'pigeon-attribution', style: {\n          position: 'absolute',\n          bottom: 0,\n          right: 0,\n          fontSize: '11px',\n          padding: '2px 5px',\n          background: 'rgba(255, 255, 255, 0.7)',\n          fontFamily: \"'Helvetica Neue', Helvetica, Arial, sans-serif\",\n          color: '#333'\n        } }, attributionPrefix === false ? null : _infact.React.createElement('span', null, attributionPrefix || _infact.React.createElement('a', { href: 'https://github.com/mariusandra/pigeon-maps', style: linkStyle }, 'Pigeon'), ' | '), attribution || _infact.React.createElement('span', null, '  ', _infact.React.createElement('a', { href: 'https://www.openstreetmap.org/copyright', style: linkStyle }, 'OpenStreetMap'), ' contributors'));\n    }\n  }, {\n    key: 'render',\n    value: function () {\n      var _props3 = this.props,\n          width = _props3.width,\n          height = _props3.height;\n\n      return _infact.React.createElement('div', { style: {\n          width: width,\n          height: height,\n          position: 'relative',\n          display: 'inline-block',\n          overflow: 'hidden',\n          background: '#dddddd'\n        },\n        ref: this.setRef,\n        onWheel: this.handleWheel }, this.renderTiles(), this.renderOverlays(), this.renderAttribution());\n    }\n  }]);\n\n  return Map;\n}(_infact.Component);\n\nMap.propTypes = {\n  center: _infact.PropTypes.array,\n  defaultCenter: _infact.PropTypes.array,\n  zoom: _infact.PropTypes.number,\n  defaultZoom: _infact.PropTypes.number,\n  width: _infact.PropTypes.number,\n  height: _infact.PropTypes.number,\n  provider: _infact.PropTypes.func,\n  children: _infact.PropTypes.node,\n  animate: _infact.PropTypes.bool,\n  attribution: _infact.PropTypes.any,\n  attributionPrefix: _infact.PropTypes.any,\n\n  onClick: _infact.PropTypes.func,\n  onBoundsChanged: _infact.PropTypes.func\n};\nMap.defaultProps = {\n  animate: true\n};\nexports.default = Map;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-maps/lib/react/index.js\n// module id = 170\n// module chunks = 0","'use strict';\n\n// // infact = inferno + react\n\nexports.React = require('react');\nexports.ReactDOM = require('react-dom');\nexports.Component = exports.React.Component;\nexports.PropTypes = exports.React.PropTypes;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-maps/lib/react/infact.js\n// module id = 171\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parentPosition;\nfunction parentPosition(element) {\n  var x = 0;\n  var y = 0;\n  var first = true;\n\n  while (element) {\n    x += element.offsetLeft - (first ? 0 : element.scrollLeft) + element.clientLeft;\n    y += element.offsetTop - (first ? 0 : element.scrollTop) + element.clientTop;\n    element = element.offsetParent;\n    first = false;\n  }\n\n  return { x: x, y: y };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-maps/lib/react/utils/parent-position.js\n// module id = 172\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parentHasClass;\nfunction parentHasClass(element, className) {\n  while (element) {\n    if (element.classList.contains(className)) {\n      return true;\n    }\n    element = element.offsetParent;\n  }\n\n  return false;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-maps/lib/react/utils/parent-has-class.js\n// module id = 173\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = debounce;\nfunction debounce(func, wait) {\n  var timeout = void 0;\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var context = this;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      return func.apply(context, args);\n    }, wait);\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-maps/lib/react/utils/debounce.js\n// module id = 174\n// module chunks = 0","import Cluster from './Cluster'\nexport default Cluster\n\n\n// WEBPACK FOOTER //\n// ../src/index.js","import {React, Inferno, Component, PropTypes} from './infact'\nimport supercluster from 'supercluster'\nimport DefaultClusterMarker from './DefaultClusterMarker'\nconst cloneElement = process.env.BABEL_ENV === 'inferno' ? Inferno.cloneVNode : React.cloneElement\n\nconst [iLNG, iLAT] = [0, 1]\n\nexport default function Cluster (props) {\n    if (!Array.isArray(props.children)) {\n        return props.children\n    }\n    const {\n        mapState,\n        pixelToLatLng,\n        latLngToPixel,\n        children,\n        clusterMarkerRadius = 100,\n        maxZoom = 16\n    } = props\n\n    const markers = children.map(function (marker) {\n        const pixel = latLngToPixel(marker.props.anchor)\n        return cloneElement(marker, {\n            pixelToLatLng,\n            latLngToPixel,\n            left: pixel[0],\n            top: pixel[1]\n        })\n    });\n\n    const pointsForClustering = markers.map((marker) => {\n        return {\n            vNode: marker,\n            geometry: {\n                coordinates: marker.props.anchor\n            }\n        }\n    });\n\n    const index = supercluster({\n        radius: clusterMarkerRadius,\n        maxZoom\n    });\n\n    index.load(pointsForClustering);\n    const { ne, sw } = mapState.bounds\n    const [westLng, southLat, eastLng, northLat] = [sw[iLNG], sw[iLAT], ne[iLNG], ne[iLAT]];\n    const markersAndClusters = index.getClusters([westLng, southLat, eastLng, northLat], Math.floor(mapState.zoom))\n\n    const displayElements = markersAndClusters.map(markerOrCluster => {\n        let displayElement\n        const isCluster = markerOrCluster && markerOrCluster.properties && markerOrCluster.properties.cluster\n        if (isCluster) {\n            const pixelOffset = latLngToPixel(markerOrCluster.geometry.coordinates)\n            const clusterElementKey = markerOrCluster.geometry.coordinates.toString()\n            displayElement = <DefaultClusterMarker key={clusterElementKey}\n                                                   count={markerOrCluster.properties.point_count}\n                                                   pixelOffset={pixelOffset} />\n        } else {\n            displayElement = markerOrCluster.vNode\n        }\n        return displayElement\n    })\n\n    return (\n        <div className={props.className || ''}\n             style={{ position: 'absolute', height: mapState.height, width: mapState.width }}>\n            {displayElements}\n        </div>\n    )\n}\n\n\n\n\n\n\n// WEBPACK FOOTER //\n// ../src/Cluster.js","'use strict';\n\nvar kdbush = require('kdbush');\n\nmodule.exports = supercluster;\n\nfunction supercluster(options) {\n    return new SuperCluster(options);\n}\n\nfunction SuperCluster(options) {\n    this.options = extend(Object.create(this.options), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n}\n\nSuperCluster.prototype = {\n    options: {\n        minZoom: 0,   // min zoom to generate clusters on\n        maxZoom: 16,  // max zoom level to cluster the points on\n        radius: 40,   // cluster radius in pixels\n        extent: 512,  // tile extent (radius is calculated relative to it)\n        nodeSize: 64, // size of the KD-tree leaf node, affects performance\n        log: false    // whether to log timing info\n    },\n\n    load: function (points) {\n        var log = this.options.log;\n\n        if (log) console.time('total time');\n\n        var timerId = 'prepare ' + points.length + ' points';\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point\n        var clusters = points.map(createPointCluster);\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (var z = this.options.maxZoom; z >= this.options.minZoom; z--) {\n            var now = +Date.now();\n\n            // index input points into a KD-tree\n            this.trees[z + 1] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);\n\n            clusters = this._cluster(clusters, z); // create a new set of clusters for the zoom\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        // index top-level clusters\n        this.trees[this.options.minZoom] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    },\n\n    getClusters: function (bbox, zoom) {\n        var tree = this.trees[this._limitZoom(zoom)];\n        var ids = tree.range(lngX(bbox[0]), latY(bbox[3]), lngX(bbox[2]), latY(bbox[1]));\n        var clusters = [];\n        for (var i = 0; i < ids.length; i++) {\n            var c = tree.points[ids[i]];\n            clusters.push(c.id !== -1 ? this.points[c.id] : getClusterJSON(c));\n        }\n        return clusters;\n    },\n\n    getTile: function (z, x, y) {\n        var tree = this.trees[this._limitZoom(z)];\n        var z2 = Math.pow(2, z);\n        var extent = this.options.extent;\n        var r = this.options.radius;\n        var p = r / extent;\n        var top = (y - p) / z2;\n        var bottom = (y + 1 + p) / z2;\n\n        var tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    },\n\n    _addTileFeatures: function (ids, points, x, y, z2, tile) {\n        for (var i = 0; i < ids.length; i++) {\n            var c = points[ids[i]];\n            tile.features.push({\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (c.x * z2 - x)),\n                    Math.round(this.options.extent * (c.y * z2 - y))\n                ]],\n                tags: c.id !== -1 ? this.points[c.id].properties : getClusterProperties(c)\n            });\n        }\n    },\n\n    _limitZoom: function (z) {\n        return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));\n    },\n\n    _cluster: function (points, zoom) {\n        var clusters = [];\n        var r = this.options.radius / (this.options.extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (var i = 0; i < points.length; i++) {\n            var p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            var tree = this.trees[zoom + 1];\n            var neighborIds = tree.within(p.x, p.y, r);\n\n            var foundNeighbors = false;\n            var numPoints = p.numPoints;\n            var wx = p.x * numPoints;\n            var wy = p.y * numPoints;\n\n            for (var j = 0; j < neighborIds.length; j++) {\n                var b = tree.points[neighborIds[j]];\n                // filter out neighbors that are too far or already processed\n                if (zoom < b.zoom) {\n                    foundNeighbors = true;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n                    wx += b.x * b.numPoints; // accumulate coordinates for calculating weighted center\n                    wy += b.y * b.numPoints;\n                    numPoints += b.numPoints;\n                }\n            }\n\n            clusters.push(foundNeighbors ? createCluster(wx / numPoints, wy / numPoints, numPoints, -1) : p);\n        }\n\n        return clusters;\n    }\n};\n\nfunction createCluster(x, y, numPoints, id) {\n    return {\n        x: x, // weighted cluster center\n        y: y,\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id: id, // index of the source feature in the original input array\n        numPoints: numPoints\n    };\n}\n\nfunction createPointCluster(p, i) {\n    var coords = p.geometry.coordinates;\n    return createCluster(lngX(coords[0]), latY(coords[1]), 1, i);\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    var count = cluster.numPoints;\n    var abbrev = count >= 10000 ? Math.round(count / 1000) + 'k' :\n                 count >= 1000 ? (Math.round(count / 100) / 10) + 'k' : count;\n    return {\n        cluster: true,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    };\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    var sin = Math.sin(lat * Math.PI / 180),\n        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 :\n           y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    var y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (var id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/supercluster/index.js\n// module id = 177\n// module chunks = 0","'use strict';\n\nvar sort = require('./sort');\nvar range = require('./range');\nvar within = require('./within');\n\nmodule.exports = kdbush;\n\nfunction kdbush(points, getX, getY, nodeSize, ArrayType) {\n    return new KDBush(points, getX, getY, nodeSize, ArrayType);\n}\n\nfunction KDBush(points, getX, getY, nodeSize, ArrayType) {\n    getX = getX || defaultGetX;\n    getY = getY || defaultGetY;\n    ArrayType = ArrayType || Array;\n\n    this.nodeSize = nodeSize || 64;\n    this.points = points;\n\n    this.ids = new ArrayType(points.length);\n    this.coords = new ArrayType(points.length * 2);\n\n    for (var i = 0; i < points.length; i++) {\n        this.ids[i] = i;\n        this.coords[2 * i] = getX(points[i]);\n        this.coords[2 * i + 1] = getY(points[i]);\n    }\n\n    sort(this.ids, this.coords, this.nodeSize, 0, this.ids.length - 1, 0);\n}\n\nKDBush.prototype = {\n    range: function (minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    },\n\n    within: function (x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n};\n\nfunction defaultGetX(p) { return p[0]; }\nfunction defaultGetY(p) { return p[1]; }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/kdbush/src/kdbush.js\n// module id = 178\n// module chunks = 0","'use strict';\n\nmodule.exports = sortKD;\n\nfunction sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    var m = Math.floor((left + right) / 2);\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        var t = coords[2 * k + inc];\n        var i = left;\n        var j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/kdbush/src/sort.js\n// module id = 179\n// module chunks = 0","'use strict';\n\nmodule.exports = range;\n\nfunction range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var x, y;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/kdbush/src/range.js\n// module id = 180\n// module chunks = 0","'use strict';\n\nmodule.exports = within;\n\nfunction within(ids, coords, qx, qy, r, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var r2 = r * r;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        var x = coords[2 * m];\n        var y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    var dx = ax - bx;\n    var dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/kdbush/src/within.js\n// module id = 181\n// module chunks = 0","import {React, Inferno, Component} from './infact'\n\nconst colors = {\n    small: ['rgba(181, 226, 140, 0.6)', 'rgba(110, 204, 57, 0.7)'],\n    medium: ['rgba(241, 211, 87, 0.6)', 'rgba(240, 194, 12, 0.7)'],\n    big: ['rgba(253, 156, 115, 0.6)', 'rgba(241, 128, 23, 0.7)'],\n}\nconst defaultCountToColor = count => {\n    return count > 20 ? colors.big : count > 7 ? colors.medium : colors.small\n}\n\nconst styleFromCount = count => {\n    const colors = defaultCountToColor(count)\n    return {\n        width: 30,\n        height: 30,\n        borderRadius: '50%',\n        borderWidth: 3,\n        borderColor: colors[0],\n        borderStyle: 'solid',\n        background: colors[1],\n        position: 'absolute',\n        display: 'flex',\n        flexDirection: 'column',\n        justifyContent: 'center',\n        textAlign: 'center',\n        cursor: 'default'\n    }\n}\n\nexport default function DefaultClusterMarker ({ pixelOffset, count }) {\n    return (\n        <div style={Object.assign(styleFromCount(count), {\n            left: pixelOffset[0],\n            top: pixelOffset[1]\n        })}>\n            {count}\n        </div>\n    )\n}\n\n\n// WEBPACK FOOTER //\n// ../src/DefaultClusterMarker.js","if (process.env.BABEL_ENV === 'inferno') {\n  module.exports = require('./lib/inferno/index.js')\n}\nif (process.env.BABEL_ENV === 'react') {\n  module.exports = require('./lib/react/index.js')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-marker/infact.js\n// module id = 183\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nvar _infact = require('./infact');\n\nvar _pin = require('./img/pin.png');\n\nvar _pin2 = _interopRequireDefault(_pin);\n\nvar _pin2x = require('./img/pin@2x.png');\n\nvar _pin2x2 = _interopRequireDefault(_pin2x);\n\nvar _pinHover = require('./img/pin-hover.png');\n\nvar _pinHover2 = _interopRequireDefault(_pinHover);\n\nvar _pinHover2x = require('./img/pin-hover@2x.png');\n\nvar _pinHover2x2 = _interopRequireDefault(_pinHover2x);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar imageOffset = {\n  left: 15,\n  top: 31\n};\n\nvar Marker = function (_Component) {\n  _inherits(Marker, _Component);\n\n  function Marker(props) {\n    _classCallCheck(this, Marker);\n\n    var _this = _possibleConstructorReturn(this, (Marker.__proto__ || Object.getPrototypeOf(Marker)).call(this, props));\n\n    _this.eventParameters = function (event) {\n      return {\n        event: event,\n        anchor: _this.props.anchor,\n        payload: _this.props.payload\n      };\n    };\n\n    _this.handleClick = function () {\n      _this.props.onClick && _this.props.onClick(_this.eventParameters());\n    };\n\n    _this.handleContextMenu = function () {\n      _this.props.onContextMenu && _this.props.onContextMenu(_this.eventParameters());\n    };\n\n    _this.handleMouseOver = function () {\n      _this.props.onMouseOver && _this.props.onMouseOver(_this.eventParameters());\n      _this.setState({ hover: true });\n    };\n\n    _this.handleMouseOut = function () {\n      _this.props.onMouseOut && _this.props.onMouseOut(_this.eventParameters());\n      _this.setState({ hover: false });\n    };\n\n    _this.state = {\n      hover: false\n    };\n    return _this;\n  }\n\n  // what do you expect to get back with the event\n\n\n  _createClass(Marker, [{\n    key: 'isRetina',\n\n    // controls\n    value: function () {\n      return typeof window !== 'undefined' && window.devicePixelRatio >= 2;\n    }\n\n    // modifiers\n\n  }, {\n    key: 'isHover',\n    value: function () {\n      return typeof this.props.hover === 'boolean' ? this.props.hover : this.state.hover;\n    }\n  }, {\n    key: 'image',\n    value: function () {\n      return this.isRetina() ? this.isHover() ? _pinHover2x2.default : _pin2x2.default : this.isHover() ? _pinHover2.default : _pin2.default;\n    }\n\n    // lifecycle\n\n  }, {\n    key: 'componentDidMount',\n    value: function () {\n      var images = this.isRetina() ? [_pin2x2.default, _pinHover2x2.default] : [_pin2.default, _pinHover2.default];\n\n      images.forEach(function (image) {\n        var img = new window.Image();\n        img.src = image;\n      });\n    }\n\n    // delegators\n\n  }, {\n    key: 'render',\n\n    // render\n\n    value: function () {\n      var _props = this.props,\n          left = _props.left,\n          top = _props.top,\n          onClick = _props.onClick;\n\n      var style = {\n        position: 'absolute',\n        transform: 'translate(' + (left - imageOffset.left) + 'px, ' + (top - imageOffset.top) + 'px)',\n        cursor: onClick ? 'pointer' : 'default'\n      };\n\n      return _infact.React.createElement('div', { style: style,\n        className: 'pigeon-click-block',\n        onClick: this.handleClick,\n        onContextMenu: this.handleContextMenu,\n        onMouseOver: this.handleMouseOver,\n        onMouseOut: this.handleMouseOut }, _infact.React.createElement('img', { src: this.image(), width: 29, height: 34, alt: '' }));\n    }\n  }]);\n\n  return Marker;\n}(_infact.Component);\n\nMarker.propTypes = {\n  // input, passed to events\n  anchor: _infact.PropTypes.array.isRequired,\n  payload: _infact.PropTypes.any,\n\n  // optional modifiers\n  hover: _infact.PropTypes.bool,\n\n  // callbacks\n  onClick: _infact.PropTypes.func,\n  onContextMenu: _infact.PropTypes.func,\n  onMouseOver: _infact.PropTypes.func,\n  onMouseOut: _infact.PropTypes.func,\n\n  // pigeon variables\n  left: _infact.PropTypes.number,\n  top: _infact.PropTypes.number,\n\n  // pigeon functions\n  latLngToPixel: _infact.PropTypes.func,\n  pixelToLatLng: _infact.PropTypes.func\n};\nexports.default = Marker;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-marker/lib/react/index.js\n// module id = 184\n// module chunks = 0","'use strict';\n\n// // infact = inferno + react\n\nexports.React = require('react');\nexports.ReactDOM = require('react-dom');\nexports.Component = exports.React.Component;\nexports.PropTypes = exports.React.PropTypes;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-marker/lib/react/infact.js\n// module id = 185\n// module chunks = 0","module.exports = __webpack_public_path__ + \"pin.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-marker/lib/react/img/pin.png\n// module id = 186\n// module chunks = 0","module.exports = __webpack_public_path__ + \"pin@2x.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-marker/lib/react/img/pin@2x.png\n// module id = 187\n// module chunks = 0","module.exports = __webpack_public_path__ + \"pin-hover.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-marker/lib/react/img/pin-hover.png\n// module id = 188\n// module chunks = 0","module.exports = __webpack_public_path__ + \"pin-hover@2x.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/pigeon-marker/lib/react/img/pin-hover@2x.png\n// module id = 189\n// module chunks = 0","module.exports = __webpack_public_path__ + \"index.html\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.html\n// module id = 190\n// module chunks = 0"],"sourceRoot":""}